# Поля слишком узки: Write-up

Что ж, нам действительно нужно найти такие положительные целые числа _x_, _y_, _z_, что _x_​³ + _y_​³ = _z_​³. А потом ещё и другие, такие, что _x_​⁴ + _y_​⁴ = _z_​⁴.

> Невозможность существованиях таких наборов чисел для степеней 3 и 4 была показана давно, но окончательно доказать теорему для всех степеней удалось лишь в 1995 году математику Эндрю Уайлсу.

Вернее, не так. Нам достаточно _убедить валидатор_ в том, что числа, которые мы предъявим, обладают этим свойством. [Исходный код валидатора](app/validator.py) нам любезно предоставлен. По сути, если отбросить всякие неинтересные действия по преобразованию типов и проверке корректности самих чисел, остаются вот такие условия:

```python
POWER_CUBIC = 3.0
POWER_QUARTIC = 4.0

...

if x_cubic ** POWER_CUBIC + y_cubic ** POWER_CUBIC != z_cubic ** POWER_CUBIC:
    ...

if x_quartic ** POWER_QUARTIC + y_quartic ** POWER_QUARTIC != z_quartic ** POWER_QUARTIC:
    ...
```

Наши числа возводятся в степень `3.0` и `4.0`. Это отличается от возведения в степень `3` и `4`, которое являлось бы точным вычислением благодаря встроенной в Python поддержке _длинной арифметики_. Здесь показатели степени являются значениями типа float, значит, и типом результата всей операции тоже является float, а он способнен хранить числа лишь с ограниченной точностью.

Таким образом, валидатор можно обмануть немного неточным решением, если погрешность будет достаточно мала. Ищем в интернете [fermat last theorem near misses](https://google.com/search?q=fermat+last+theorem+near+misses).

Первый результат — [обсуждение на StackExchange](https://math.stackexchange.com/questions/526330/fermats-last-theorem-near-misses), где показан способ генерировать неточные решения третьей степени со сколь угодно малой погрешностью. Например, можно взять _m_ = 244, тогда получится, что _x_ = 179097, _y_ = 43759448, _z_ = 43759449.

Второй результат — [страничка одного гарвардского математика](https://people.math.harvard.edu/~elkies/ferm.html), где он приводит некоторые неточные решения для более высоких степеней, включая нужную нам четвёртую. Берём оттуда пример с самым большим по модулю _r_, чтобы наверняка: _x_ = 419904, _y_ = 1257767, _z_ = 1261655.

Вводим значения, получаем флаг.

Флаг: **ugra_i_wish_fermat_had_css_63829b4f1f8c**
