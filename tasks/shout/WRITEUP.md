# Поорите: Write-up

Перед нами задание на бинарную эксплуатацию. Посмотрим, что оно умеет, не открывая ни бинарный файл, ни дебаггер.

Нередко в таких заданиях бывает переполнение, и, чтобы забить нужное количество байт, обычно используют буквы `A`. Возможно, на это нам и намекают, когда просят поорать. Что ж, попробуем: введём 100 букв `A`:

```bash
$ ./shout 
Shout here: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Too weak, try again.
```

Попробуем ввести больше букв. Например, 2000:

```
Too weak, try again.
Segmentation fault (core dumped)
```

На этот раз приложение упало с ошибкой. Это означает, что уязвимость всё-таки есть — и эта уязвимость — переполнение стека. Уязвимость заключается в том, что приложение неправильно валидирует данные, хранящие на стеке приложения: мы можем ввести больше данных, чем есть места — в этом случае приложение их просто начнёт писать дальше, затирая какие-то важные данные.

Всё-таки дальше без изучения приложения не обойтись. Откроем его в IDA или Cutter и посмотрим, что внутри. Сразу замечаем какую-то непонятную секцию `.flags`, местоположение которой, скажем прямо, удивляет — она находится через 532 МБ от начала приложения.

В этой секции мы находим единственную функцию `print_flag` по адресу `0x21414141`, которая открывает файл `flag.txt` и печатает его. Казалось бы, вот и решение — но незадача: эта функция нигде в коде не вызывается.

Теперь нужно понять, как можно использовать найденную уязвимость для вызова функции. На самом деле, стек вызовов выглядит примерно так:

```
... | shout                                 | main                                  | ...
... | local vars | ebp | return addr | args | local vars | ebp | return addr | args | ...
```

Таким образом, если мы затрём данные после локальной переменной в функции `shout`, мы сможем переписать `ebp`, `return addr` и всё, что находится дальше. А что произойдёт потом? А потом программа успешно дойдёт до конца функции и попробует вернуться в «предыдущую функцию» по адресу, который лежит в return addr. И, если нам удастся подставить сюда адрес нашей функции `print_flag`, то мы победим.

Следующая проблема — формат ввода. Как известно, мы вводим в программу буквы, а адрес перехода состоит из цифр. Что же делать? Тут всё очень просто — мы вводим те символы, шестнадцатеричные коды которых соответствуют байтам нашего адреса. Есть одно маленькое «но» — в Linux порядок байт little endian, поэтому адрес нужно вводить «наоборот». Числу `41` соответствует символ `A`, а числу `21` — символ `!`. Получается, наш адрес мы будем вводить как `AAA!`.

Наконец, нужно понять, сколько байт нам нужно всего. Можно просто перебрать. Проще — локально. Создадим файл `flag.txt` и будем запускать наш файл с разным количеством `A`. Можно отреверсить этот бинарный файл и узнать, сколько байт выделяется на стеке.

В итоге мы получаем эксплойт — 1039 букв `A` и восклицательный знак. Ровно так нужно проорать, чтобы получить флаг.

Флаг: **ugra_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA_690868a2aeaff4c1**
