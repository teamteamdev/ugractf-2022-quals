# Веб-департамент: Write-up

Сначала зайдём на сайт с помощью любого приложения для двухфакторной аутентификации — например, Google Authenticator или Authy. На сайте есть две страницы — одна позволяет запросить содержимое любого сайта, а вторая — отправить сообщение.

Обращаем внимание, что все ответы от сервера сопровождаются заголовком `X-Backend: 10.13.37.159`. Это намекает нам на атаку SSRF (Server-side request forgery) — мы можем получить доступ к внутренним ресурсам.

Начнём с сети `/24` и популярных веб-портов — например, с `:80`. В локальной сети обнаруживаем хост `http://10.13.37.62` — по этому адресу отдаётся некий JSON.

Изучая его, приходим к выводу, что это схема API — доступных эндпоинтов на этом сервере и формата запросов. Всего видим два эндпоинта:

* `GET /request-otp?username=...`
* `POST /check-otp` `username=...&code=...`

POST-запросы мы делать не можем, попробуем GET с именем пользователя `admin`: `http://10.13.37.62/request-otp?username=admin`. Получаем непонятный текст, но видим в нём `PNG`. Вероятно, это такая же картинка с кодом, что была у `andy77`.

`\x89` выглядит как байт с хекс-кодом 89. Очень похоже на то, как Python кодирует бинарные строки. И действительно, даже куки намекают на использование aiohttp — это веб-фреймворк для Python.

Самый простой способ получить картинку — обернуть это всё в `b'...'` — это байтовая строка, и вывести полученную переменную в файл. Код, кстати, можно скопировать из какого-нибудь таска на криптографию:

```python3
image = b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR...\x00IEND\xaeB`\x82'
with open("image.png", "wb") as f:
    f.write(image)
```

Открываем картинку, видим QR-код администратора. Входим, получаем флаг.

Флаг: **ugra_isolate_your_public_hosts_d611010a81dd**
